namespace AtQrExtractor.Services;

using System.Security.Cryptography;
using System.Text;
using AtQrExtractor.Models;
using UglyToad.PdfPig;
using PDFtoImage;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.Processing;
using SixLabors.ImageSharp.PixelFormats;
using ZXing;
using ZXing.Common;
using Serilog;
using SkiaSharp;

/// <summary>
/// Extracts all QR codes from PDF and image files using multi-strategy detection.
/// </summary>
/// <remarks>
/// <para>
/// Implements comprehensive QR code extraction optimized for Portuguese fiscal documents.
/// Uses a progressive detection approach combining embedded image extraction, full-page rendering,
/// multi-scale analysis, and image enhancement techniques.
/// </para>
/// <para><b>IMPORTANT:</b> This implementation detects ALL QR codes per page/image, not just the first occurrence.</para>
/// <para><b>Detection Strategies (applied in order):</b></para>
/// <list type="number">
///   <item>
///     <term>Embedded Image Extraction (~10ms per image)</term>
///     <description>
///       Extracts QR codes directly from embedded PDF images. Fastest method,
///       ideal for QR codes stored as separate image objects.
///     </description>
///   </item>
///   <item>
///     <term>Full Page Rendering (~100-500ms per page)</term>
///     <description>
///       Renders entire PDF page to image and scans for QR codes. Captures vector-based
///       QR codes and those generated by billing software like ZVU. Always executed
///       regardless of embedded image results to ensure complete detection.
///     </description>
///   </item>
///   <item>
///     <term>Image Enhancement (optional)</term>
///     <description>
///       Applies contrast adjustment and sharpening to improve detection of degraded
///       or low-quality QR codes.
///     </description>
///   </item>
///   <item>
///     <term>Multi-Scale Detection (optional)</term>
///     <description>
///       Attempts detection at 0.5x, 0.75x, 1.5x, and 2.0x scales to handle QR codes
///       with unusual sizes or aspect ratios.
///     </description>
///   </item>
/// </list>
/// <para><b>Supported Formats:</b></para>
/// <list type="bullet">
///   <item><description>PDF (multi-page)</description></item>
///   <item><description>PNG, JPEG, BMP, TIFF/TIF</description></item>
/// </list>
/// </remarks>
public sealed class QrProcessor
{
    #region Constants

    private const int MinimumDpi = 300;
    private static readonly string[] SupportedImageExtensions = { ".pdf", ".png", ".jpg", ".jpeg", ".bmp", ".tiff", ".tif" };
    private const int MinimumImageDimension = 100;
    private static readonly float[] MultiScaleFactors = { 0.5f, 0.75f, 1.5f, 2.0f };
    private const float GaussianSharpenAmount = 0.5f;

    #endregion

    #region Private Fields

    private readonly int _dpi;
    private readonly bool _useMultiScaleDetection;
    private readonly bool _useImageEnhancements;

    #endregion

    #region Constructor

    /// <summary>
    /// Initializes a new instance of the <see cref="QrProcessor"/> class.
    /// </summary>
    /// <param name="dpi">
    /// The DPI resolution for PDF page rendering. Minimum 300, recommended 600 for most documents.
    /// Higher values improve detection of small QR codes but increase processing time.
    /// </param>
    /// <param name="useMultiScaleDetection">
    /// Whether to enable multi-scale detection at 0.5x, 0.75x, 1.5x, and 2.0x image sizes.
    /// Improves success rate but increases processing time by ~4x.
    /// </param>
    /// <param name="useImageEnhancements">
    /// Whether to apply contrast and sharpening enhancements to improve detection
    /// of degraded or low-quality QR codes.
    /// </param>
    public QrProcessor(int dpi, bool useMultiScaleDetection = true, bool useImageEnhancements = true)
    {
        _dpi = Math.Max(MinimumDpi, dpi);
        _useMultiScaleDetection = useMultiScaleDetection;
        _useImageEnhancements = useImageEnhancements;

        Log.Information("QrProcessor initialized with DPI={DPI}, MultiScale={MultiScale}, Enhancements={Enhancements}",
            _dpi, _useMultiScaleDetection, _useImageEnhancements);
    }

    #endregion

    #region Public Methods

    /// <summary>
    /// Processes multiple input paths (files and directories) for QR code extraction.
    /// </summary>
    /// <param name="paths">
    /// Array of file or directory paths. Directories are recursively searched for supported files.
    /// </param>
    /// <returns>
    /// A list of processing results, one per unique file discovered. Each result contains
    /// extracted QR payloads and any errors encountered.
    /// </returns>
    /// <remarks>
    /// Invalid paths are logged as warnings but do not stop processing. Duplicate file paths
    /// are automatically deduplicated.
    /// </remarks>
    public async Task<List<FileProcessingResult>> ProcessInputs(string[] paths)
    {
        var allFiles = CollectFilesFromPaths(paths);

        var results = new List<FileProcessingResult>();
        foreach (var file in allFiles.Distinct())
        {
            try
            {
                var result = await ProcessFile(file);
                results.Add(result);
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Failed to process {File}", file);
                results.Add(new FileProcessingResult { FilePath = file, Errors = { ex.Message } });
            }
        }

        return results;
    }

    /// <summary>
    /// Processes all supported files in a directory (non-recursive).
    /// </summary>
    /// <param name="directoryPath">The directory path to scan for supported files.</param>
    /// <returns>
    /// A list of processing results for all supported files found in the directory.
    /// </returns>
    /// <remarks>
    /// Only scans the top-level directory. Subdirectories are not included.
    /// Logs the count and names of discovered files.
    /// </remarks>
    public async Task<List<FileProcessingResult>> ProcessDirectory(string directoryPath)
    {
        var results = new List<FileProcessingResult>();

        var files = Directory.GetFiles(directoryPath, "*.*", SearchOption.TopDirectoryOnly)
            .Where(f => SupportedImageExtensions.Contains(Path.GetExtension(f).ToLower()))
            .ToList();

        Log.Information("Found {Count} supported files", files.Count);

        foreach (var file in files)
        {
            Log.Information("  - {FileName}", Path.GetFileName(file));
        }

        foreach (var file in files)
        {
            try
            {
                var result = await ProcessFile(file);
                results.Add(result);
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Error processing file: {File}", file);
                results.Add(new FileProcessingResult
                {
                    FilePath = file,
                    Errors = new List<string> { ex.Message }
                });
            }
        }

        return results;
    }

    #endregion

    #region Private Methods - File Collection

    /// <summary>
    /// Collects all supported files from the provided paths.
    /// </summary>
    /// <param name="paths">Array of file or directory paths to process.</param>
    /// <returns>
    /// A list of absolute file paths for all supported files found. Directories are
    /// recursively searched. Invalid paths are logged and skipped.
    /// </returns>
    private List<string> CollectFilesFromPaths(string[] paths)
    {
        var allFiles = new List<string>();

        foreach (var path in paths)
        {
            if (File.Exists(path))
            {
                allFiles.Add(path);
            }
            else if (Directory.Exists(path))
            {
                var files = Directory.EnumerateFiles(path, "*.*", SearchOption.AllDirectories)
                                     .Where(f => SupportedImageExtensions.Contains(Path.GetExtension(f).ToLower()));
                allFiles.AddRange(files);
            }
            else
            {
                Log.Warning("Input path not found: {Path}", path);
            }
        }

        return allFiles;
    }

    #endregion

    #region Private Methods - File Processing

    /// <summary>
    /// Processes a single file and extracts all QR codes.
    /// </summary>
    /// <param name="filePath">The absolute path of the file to process.</param>
    /// <returns>
    /// A <see cref="FileProcessingResult"/> containing all extracted QR payloads
    /// and any processing errors.
    /// </returns>
    /// <remarks>
    /// Routes to specialized handlers based on file extension. PDF files use multi-page
    /// processing; image files are processed directly.
    /// </remarks>
    private async Task<FileProcessingResult> ProcessFile(string filePath)
    {
        Log.Information("Processing file: {File}", filePath);

        var extension = Path.GetExtension(filePath).ToLower();
        var result = new FileProcessingResult { FilePath = filePath };

        if (extension == ".pdf")
        {
            return await ProcessPdf(filePath);
        }
        else
        {
            var payloads = await Task.Run(() => ProcessImage(filePath));
            result.QrPayloads.AddRange(payloads);
            return result;
        }
    }

    #endregion

    #region Private Methods - PDF Processing

    /// <summary>
    /// Processes a PDF file and extracts QR codes from all pages.
    /// </summary>
    /// <param name="pdfPath">The absolute path of the PDF file.</param>
    /// <returns>
    /// A <see cref="FileProcessingResult"/> with all unique QR codes found across all pages.
    /// </returns>
    /// <remarks>
    /// Uses hash-based deduplication to avoid returning duplicate QR codes that appear
    /// on multiple pages. Page-level errors are captured but do not stop processing
    /// of subsequent pages.
    /// </remarks>
    private async Task<FileProcessingResult> ProcessPdf(string pdfPath)
    {
        return await Task.Run(() =>
        {
            var result = new FileProcessingResult { FilePath = pdfPath };
            var foundHashes = new HashSet<string>();

            try
            {
                using var document = PdfDocument.Open(pdfPath);
                Log.Debug("PDF has {PageCount} pages", document.NumberOfPages);

                for (int pageNum = 1; pageNum <= document.NumberOfPages; pageNum++)
                {
                    Log.Information("--> Scanning page {Page} of {Total}...", pageNum, document.NumberOfPages);

                    try
                    {
                        ProcessPageForQrCodes(document, pageNum, foundHashes, result);
                    }
                    catch (Exception ex)
                    {
                        Log.Warning(ex, "Error processing page {Page} of {File}", pageNum, pdfPath);
                        result.Errors.Add($"Page {pageNum}: {ex.Message}");
                    }
                }

                LogQrCodeExtractionResult(result);
            }
            catch (Exception ex)
            {
                Log.Error(ex, "Failed to open PDF: {File}", pdfPath);
                result.Errors.Add($"Failed to open PDF: {ex.Message}");
            }

            return result;
        });
    }

    /// <summary>
    /// Processes a single PDF page using both embedded image and page rendering strategies.
    /// </summary>
    /// <param name="document">The opened PDF document.</param>
    /// <param name="pageNum">The one-based page number to process.</param>
    /// <param name="foundHashes">
    /// Set of already-found QR code hashes for deduplication across pages.
    /// </param>
    /// <param name="result">The result object to append discovered QR codes to.</param>
    /// <remarks>
    /// <para><b>Strategy 1:</b> Attempts to extract QR codes from embedded images (fast ~10ms).</para>
    /// <para><b>Strategy 2:</b> Always renders the full page and scans for QR codes (~100-500ms)
    /// to catch vector-based or programmatically-generated QR codes that are not embedded as images.</para>
    /// <para>Both strategies run regardless of initial success to ensure comprehensive detection.</para>
    /// </remarks>
    private void ProcessPageForQrCodes(PdfDocument document, int pageNum, HashSet<string> foundHashes, FileProcessingResult result)
    {
        var page = document.GetPage(pageNum);
        int qrCountBeforeThisPage = result.QrPayloads.Count;

        Log.Debug("Strategy 1: Checking embedded images on page {Page}", pageNum);
        var images = page.GetImages();

        if (images.Any())
        {
            Log.Debug("Found {Count} embedded images", images.Count());

            foreach (var image in images)
            {
                ProcessEmbeddedImage(pageNum, foundHashes, result, image);
            }
        }
        else
        {
            Log.Debug("No embedded images found on page {Page}", pageNum);
        }

        Log.Debug("Strategy 2: Rendering page {Page} to detect additional QR codes", pageNum);
        RenderAndScanPage(pageNum, pdfPath: result.FilePath, page, foundHashes, result);

        int qrFoundOnThisPage = result.QrPayloads.Count - qrCountBeforeThisPage;
        if (qrFoundOnThisPage > 0)
        {
            Log.Information("Found {Count} QR code(s) on page {Page}", qrFoundOnThisPage, pageNum);
        }
        else
        {
            Log.Debug("No QR codes found on page {Page}", pageNum);
        }
    }

    /// <summary>
    /// Attempts to extract QR codes from a single embedded PDF image.
    /// </summary>
    /// <param name="pageNum">The page number (for logging purposes).</param>
    /// <param name="foundHashes">Hash set for deduplication.</param>
    /// <param name="result">Result object to append discovered QR codes to.</param>
    /// <param name="image">The embedded PDF image to process.</param>
    /// <remarks>
    /// Failures to decode individual images are logged at debug level and do not affect
    /// processing of other images or pages.
    /// </remarks>
    private void ProcessEmbeddedImage(int pageNum, HashSet<string> foundHashes, FileProcessingResult result, UglyToad.PdfPig.Content.IPdfImage image)
    {
        try
        {
            var bytes = image.RawBytes.ToArray();
            using var ms = new MemoryStream(bytes);

            var payloads = ProcessImageStream(ms);
            foreach (var payload in payloads)
            {
                if (!foundHashes.Contains(payload.Hash))
                {
                    foundHashes.Add(payload.Hash);
                    result.QrPayloads.Add(payload);
                    Log.Information("Found QR code in embedded image on page {Page}", pageNum);
                }
            }
        }
        catch (Exception ex)
        {
            Log.Debug(ex, "Could not process embedded image from page {Page}", pageNum);
        }
    }

    /// <summary>
    /// Renders a PDF page to an image and scans for all QR codes.
    /// </summary>
    /// <param name="pageNum">The one-based page number.</param>
    /// <param name="pdfPath">The full path to the PDF file (required for rendering).</param>
    /// <param name="page">The page object from PdfPig.</param>
    /// <param name="foundHashes">Hash set for deduplication.</param>
    /// <param name="result">Result object to append discovered QR codes to.</param>
    /// <remarks>
    /// Renders at the configured DPI setting. Higher DPI improves detection of small QR codes
    /// but significantly increases processing time and memory usage. Page rendering errors
    /// are logged but do not throw exceptions.
    /// </remarks>
    private void RenderAndScanPage(int pageNum, string pdfPath, UglyToad.PdfPig.Content.Page page, HashSet<string> foundHashes, FileProcessingResult result)
    {
        Log.Debug("Strategy 2: Rendering page {Page} at {DPI} DPI", pageNum, _dpi);

        SKBitmap? renderedBitmap = null;
        Image<L8>? renderedImage = null;

        try
        {
            int targetWidth = (int)(page.Width * _dpi / 72.0);
            int targetHeight = (int)(page.Height * _dpi / 72.0);

            Log.Debug("Target render size: {Width}x{Height} pixels", targetWidth, targetHeight);

            byte[] pdfBytes = File.ReadAllBytes(pdfPath);
            var renderOptions = new RenderOptions { Width = targetWidth, Height = targetHeight };
            Index pageIndex = pageNum - 1;

            renderedBitmap = Conversion.ToImage(pdfBytes, page: pageIndex, options: renderOptions);
            renderedImage = ConvertSkBitmapToImageSharp(renderedBitmap);

            Log.Debug("Rendered page to {Width}x{Height} pixels", renderedImage.Width, renderedImage.Height);

            var payloads = DecodeAllQrCodesFromImage(renderedImage);

            foreach (var payload in payloads)
            {
                if (!foundHashes.Contains(payload.Hash))
                {
                    foundHashes.Add(payload.Hash);
                    result.QrPayloads.Add(payload);
                    Log.Information("Found QR code by rendering page {Page}", pageNum);
                }
            }

            if (payloads.Count == 0)
            {
                Log.Debug("No QR codes found in rendered page {Page}", pageNum);
            }
        }
        catch (Exception ex)
        {
            Log.Warning(ex, "Failed to render page {Page}", pageNum);
            result.Errors.Add($"Page {pageNum}: Could not render page - {ex.Message}");
        }
        finally
        {
            renderedImage?.Dispose();
            renderedBitmap?.Dispose();
        }
    }

    /// <summary>
    /// Logs the final QR code extraction result for a PDF.
    /// </summary>
    /// <param name="result">The processing result containing extracted QR codes.</param>
    private void LogQrCodeExtractionResult(FileProcessingResult result)
    {
        if (result.QrPayloads.Any())
        {
            Log.Information("Extracted {Count} unique QR code(s) from PDF", result.QrPayloads.Count);
        }
        else
        {
            Log.Warning("No QR codes found in PDF after trying all strategies");
        }
    }

    #endregion

    #region Private Methods - Image Processing

    /// <summary>
    /// Extracts all QR codes from a standalone image file.
    /// </summary>
    /// <param name="imagePath">The absolute path to the image file.</param>
    /// <returns>
    /// A list of all unique QR payloads detected in the image.
    /// </returns>
    /// <remarks>
    /// Converts images to 8-bit grayscale (L8) for optimal QR detection performance.
    /// Applies multi-strategy detection if enabled in processor configuration.
    /// </remarks>
    private List<QrPayload> ProcessImage(string imagePath)
    {
        using var image = Image.Load<L8>(imagePath);
        var payloads = DecodeAllQrCodesFromImage(image);

        if (payloads.Count == 0)
        {
            Log.Warning("  No QR codes found in image");
        }
        else
        {
            Log.Information("  Found {Count} QR code(s) in image", payloads.Count);
        }

        return payloads;
    }

    /// <summary>
    /// Extracts all QR codes from an image stream.
    /// </summary>
    /// <param name="stream">A readable stream containing image data.</param>
    /// <returns>
    /// A list of all unique QR payloads detected in the stream.
    /// </returns>
    /// <remarks>
    /// Used primarily for processing embedded PDF images. Stream is not disposed by this method.
    /// </remarks>
    private List<QrPayload> ProcessImageStream(Stream stream)
    {
        using var image = Image.Load<L8>(stream);
        return DecodeAllQrCodesFromImage(image);
    }

    /// <summary>
    /// Converts a SkiaSharp bitmap to ImageSharp grayscale format.
    /// </summary>
    /// <param name="skBitmap">The source SkiaSharp bitmap from PDF rendering.</param>
    /// <returns>
    /// An 8-bit grayscale ImageSharp image suitable for QR detection.
    /// </returns>
    /// <remarks>
    /// Uses standard luminance formula: 0.299*R + 0.587*G + 0.114*B.
    /// Required because PDFtoImage produces SkiaSharp bitmaps while ZXing works with ImageSharp.
    /// </remarks>
    private Image<L8> ConvertSkBitmapToImageSharp(SKBitmap skBitmap)
    {
        var image = new Image<L8>(skBitmap.Width, skBitmap.Height);

        image.ProcessPixelRows(accessor =>
        {
            for (int y = 0; y < skBitmap.Height; y++)
            {
                var rowSpan = accessor.GetRowSpan(y);
                for (int x = 0; x < skBitmap.Width; x++)
                {
                    var pixel = skBitmap.GetPixel(x, y);
                    byte gray = (byte)(0.299 * pixel.Red + 0.587 * pixel.Green + 0.114 * pixel.Blue);
                    rowSpan[x] = new L8(gray);
                }
            }
        });

        return image;
    }

    #endregion

    #region Private Methods - QR Code Detection

    /// <summary>
    /// Attempts to decode all QR codes from an image using multiple detection strategies.
    /// </summary>
    /// <param name="image">The grayscale image to scan for QR codes.</param>
    /// <returns>
    /// A list of all unique QR payloads found using any strategy.
    /// </returns>
    /// <remarks>
    /// <para>Applies strategies in order:</para>
    /// <list type="number">
    ///   <item><description>Original image (fastest)</description></item>
    ///   <item><description>Enhanced image with contrast and sharpening (if enabled)</description></item>
    ///   <item><description>Multi-scale detection at 0.5x, 0.75x, 1.5x, 2.0x (if enabled)</description></item>
    /// </list>
    /// <para>Duplicate QR codes found by different strategies are automatically deduplicated by hash.</para>
    /// </remarks>
    private List<QrPayload> DecodeAllQrCodesFromImage(Image<L8> image)
    {
        var allPayloads = new List<QrPayload>();
        var foundHashes = new HashSet<string>();

        image.Mutate(x => x.AutoOrient());

        var payloads = TryDecodeAllFromImage(image, "original");
        AddUniquePayloads(allPayloads, payloads, foundHashes);

        if (_useImageEnhancements)
        {
            using var enhanced = image.Clone();
            EnhanceImageForQrDetection(enhanced);
            payloads = TryDecodeAllFromImage(enhanced, "enhanced");
            AddUniquePayloads(allPayloads, payloads, foundHashes);
        }

        if (_useMultiScaleDetection)
        {
            payloads = TryMultiScaleDetectionAll(image, foundHashes);
            AddUniquePayloads(allPayloads, payloads, foundHashes);
        }

        return allPayloads;
    }

    /// <summary>
    /// Adds only unique payloads (by hash) to the aggregate result list.
    /// </summary>
    /// <param name="allPayloads">The master list of all discovered payloads.</param>
    /// <param name="newPayloads">Newly discovered payloads to add if unique.</param>
    /// <param name="foundHashes">Set of hashes already in the master list.</param>
    private void AddUniquePayloads(List<QrPayload> allPayloads, List<QrPayload> newPayloads, HashSet<string> foundHashes)
    {
        foreach (var payload in newPayloads)
        {
            if (!foundHashes.Contains(payload.Hash))
            {
                foundHashes.Add(payload.Hash);
                allPayloads.Add(payload);
            }
        }
    }

    /// <summary>
    /// Applies image enhancements to improve QR code detection on degraded images.
    /// </summary>
    /// <param name="image">The image to enhance (modified in-place).</param>
    /// <remarks>
    /// Applies Gaussian sharpening followed by adaptive thresholding.
    /// Skips enhancement for very small images (logs at debug level).
    /// </remarks>
    private void EnhanceImageForQrDetection(Image<L8> image)
    {
        try
        {
            image.Mutate(x => x
                .GaussianSharpen(GaussianSharpenAmount)
                .AdaptiveThreshold());
        }
        catch (ArgumentOutOfRangeException ex)
        {
            Log.Debug("Skipping image enhancement for small/invalid image: {Message}", ex.Message);
        }
    }

    /// <summary>
    /// Attempts QR detection at multiple image scales to handle unusual QR code sizes.
    /// </summary>
    /// <param name="originalImage">The original image to scale and test.</param>
    /// <param name="alreadyFoundHashes">
    /// Hashes of QR codes already found at other scales to avoid duplicates.
    /// </param>
    /// <returns>
    /// A list of newly discovered QR payloads not previously found.
    /// </returns>
    /// <remarks>
    /// Tests scales: 0.5x, 0.75x, 1.5x, 2.0x. Skips scales that would produce images
    /// smaller than <see cref="MinimumImageDimension"/> pixels. Scale detection errors
    /// are logged at debug level and do not prevent testing other scales.
    /// </remarks>
    private List<QrPayload> TryMultiScaleDetectionAll(Image<L8> originalImage, HashSet<string> alreadyFoundHashes)
    {
        var allPayloads = new List<QrPayload>();

        foreach (var scale in MultiScaleFactors)
        {
            try
            {
                int newWidth = (int)(originalImage.Width * scale);
                int newHeight = (int)(originalImage.Height * scale);

                if (newWidth < MinimumImageDimension || newHeight < MinimumImageDimension) continue;

                using var scaled = originalImage.Clone();
                scaled.Mutate(x => x.Resize(newWidth, newHeight));

                var payloads = TryDecodeAllFromImage(scaled, $"scale-{scale}x");
                foreach (var payload in payloads)
                {
                    if (!alreadyFoundHashes.Contains(payload.Hash))
                    {
                        alreadyFoundHashes.Add(payload.Hash);
                        allPayloads.Add(payload);
                        Log.Debug("QR code detected at scale {Scale}x", scale);
                    }
                }
            }
            catch
            {
                Log.Debug("Error during multi-scale detection at scale {Scale}", scale);
            }
        }

        return allPayloads;
    }

    /// <summary>
    /// Attempts to decode all QR codes from an image using ZXing library.
    /// </summary>
    /// <param name="image">The grayscale image to decode.</param>
    /// <param name="strategyName">
    /// A descriptive name for logging purposes (e.g., "original", "enhanced", "scale-1.5x").
    /// </param>
    /// <returns>
    /// A list of all QR payloads successfully decoded from the image.
    /// </returns>
    /// <remarks>
    /// <para>Performs two decoding attempts:</para>
    /// <list type="number">
    ///   <item><description>Single decode with TryHarder and TryInverted options</description></item>
    ///   <item><description>Multi-decode attempt to find additional QR codes in the same image</description></item>
    /// </list>
    /// <para>Configured for QR codes only (faster than scanning all barcode formats).
    /// Uses auto-rotation and inverted image detection for improved success rate.</para>
    /// </remarks>
    private List<QrPayload> TryDecodeAllFromImage(Image<L8> image, string strategyName)
    {
        var results = new List<QrPayload>();
        var luminanceSource = new ImageSharpLuminanceSource(image);

        var reader = new BarcodeReader<byte[]>(null, null, null)
        {
            AutoRotate = true,
            Options = new DecodingOptions
            {
                PossibleFormats = new List<BarcodeFormat> { BarcodeFormat.QR_CODE },
                TryHarder = true,
                TryInverted = true,
            }
        };

        try
        {
            var result = reader.Decode(
                luminanceSource.Matrix,
                luminanceSource.Width,
                luminanceSource.Height,
                RGBLuminanceSource.BitmapFormat.Gray8
            );

            if (result != null && !string.IsNullOrWhiteSpace(result.Text))
            {
                Log.Debug("Successfully decoded QR code with {Length} characters using strategy: {Strategy}",
                    result.Text.Length, strategyName);

                results.Add(new QrPayload
                {
                    RawData = result.Text,
                    Hash = ComputeHash(result.Text),
                    SourceFiles = new List<string>()
                });
            }

            var multiReader = new BarcodeReaderGeneric();
            multiReader.Options = new DecodingOptions
            {
                PossibleFormats = new List<BarcodeFormat> { BarcodeFormat.QR_CODE },
                TryHarder = true,
                TryInverted = true,
            };

            var multiResults = multiReader.DecodeMultiple(luminanceSource);

            if (multiResults != null)
            {
                foreach (var multiResult in multiResults)
                {
                    if (multiResult != null && !string.IsNullOrWhiteSpace(multiResult.Text))
                    {
                        var hash = ComputeHash(multiResult.Text);

                        // Check if we already found this one
                        if (!results.Any(p => p.Hash == hash))
                        {
                            Log.Debug("Found additional QR code using multi-decode strategy: {Strategy}", strategyName);
                            results.Add(new QrPayload
                            {
                                RawData = multiResult.Text,
                                Hash = hash,
                                SourceFiles = new List<string>()
                            });
                        }
                    }
                }
            }
        }
        catch
        {
            Log.Debug("No QR codes detected using strategy: {Strategy}", strategyName);
        }

        return results;
    }

    #endregion

    #region Private Methods - Utilities

    /// <summary>
    /// Computes the SHA-256 hash of the specified string data.
    /// </summary>
    /// <param name="data">The string data to hash. Cannot be null.</param>
    /// <returns>A hexadecimal string representation of the SHA-256 hash.</returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="data"/> is null.</exception>
    private static string ComputeHash(string data)
    {
        var bytes = SHA256.HashData(Encoding.UTF8.GetBytes(data));
        return Convert.ToHexString(bytes);
    }

    #endregion

    #region Inner Classes

    /// <summary>
    /// Provides a luminance source implementation for ImageSharp <see cref="Image{L8}"/> images
    /// to be used with barcode reading libraries.
    /// </summary>
    private sealed class ImageSharpLuminanceSource : LuminanceSource
    {
        private readonly byte[] _luminances;

        /// <summary>
        /// Initializes a new instance of the <see cref="ImageSharpLuminanceSource"/> class
        /// from an ImageSharp grayscale image.
        /// </summary>
        /// <param name="image">The grayscale image to convert to luminance data. Must be non-null.</param>
        /// <exception cref="ArgumentNullException">Thrown when <paramref name="image"/> is null.</exception>
        public ImageSharpLuminanceSource(Image<L8> image) : base(image.Width, image.Height)
        {
            _luminances = new byte[image.Width * image.Height];

            image.ProcessPixelRows(accessor =>
            {
                for (int y = 0; y < image.Height; y++)
                {
                    var row = accessor.GetRowSpan(y);
                    for (int x = 0; x < image.Width; x++)
                    {
                        _luminances[y * image.Width + x] = row[x].PackedValue;
                    }
                }
            });
        }

        /// <summary>
        /// Gets the luminance matrix as a single array in row-major order.
        /// </summary>
        /// <value>A byte array containing the luminance values for the entire image.</value>
        public override byte[] Matrix => _luminances;

        /// <summary>
        /// Retrieves a single row of luminance data from the image.
        /// </summary>
        /// <param name="y">The zero-based row index to retrieve.</param>
        /// <param name="row">
        /// An optional pre-allocated array to store the row data. If null or insufficient length,
        /// a new array will be allocated.
        /// </param>
        /// <returns>
        /// An array containing the luminance values for the requested row.
        /// Returns <paramref name="row"/> if it was reused; otherwise returns a new array.
        /// </returns>
        /// <exception cref="ArgumentException">
        /// Thrown when <paramref name="y"/> is less than zero or greater than or equal to <see cref="Height"/>.
        /// </exception>
        public override byte[] getRow(int y, byte[] row)
        {
            if (y < 0 || y >= Height)
            {
                throw new ArgumentException("Requested row is outside the image: " + y);
            }

            int width = Width;
            if (row == null || row.Length < width)
            {
                row = new byte[width];
            }

            Array.Copy(_luminances, y * width, row, 0, width);
            return row;
        }
    }

    #endregion
}